
obj/bootrom.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <start>:
.code 32
.align 0

.global start
start:
    b       Reset
   0:	ea000006 	b	20 <Reset>
    b       0x00102008
   4:	ea0407fe 	b	102004 <__CallRam_from_thumb+0x101eb0>
    b       0x00102010
   8:	ea0407fe 	b	102008 <__CallRam_from_thumb+0x101eb4>
    b       0x00102018
   c:	ea0407fe 	b	10200c <__CallRam_from_thumb+0x101eb8>
    b       0x00102020
  10:	ea0407fe 	b	102010 <__CallRam_from_thumb+0x101ebc>
    b       0x00102028
  14:	ea0407fe 	b	102014 <__CallRam_from_thumb+0x101ec0>
    b       0x00102030
  18:	ea0407fe 	b	102018 <__CallRam_from_thumb+0x101ec4>
    b       0x00102038
  1c:	ea0407fe 	b	10201c <__CallRam_from_thumb+0x101ec8>

00000020 <Reset>:

Reset:
    ldr     sp,     = 0x00203ff8
  20:	e59fd024 	ldr	sp, [pc, #36]	; 4c <CallRam+0x8>
    bl      CMain
  24:	eb000047 	bl	148 <__CMain_from_arm>

00000028 <Fiq>:

Fiq:
    b       Fiq
  28:	eafffffe 	b	28 <Fiq>

0000002c <UndefinedInstruction>:
UndefinedInstruction:
    b       UndefinedInstruction
  2c:	eafffffe 	b	2c <UndefinedInstruction>

00000030 <SoftwareInterrupt>:
SoftwareInterrupt:
    b       SoftwareInterrupt
  30:	eafffffe 	b	30 <SoftwareInterrupt>

00000034 <PrefetchAbort>:
PrefetchAbort:
    b       PrefetchAbort
  34:	eafffffe 	b	34 <PrefetchAbort>

00000038 <DataAbort>:
DataAbort:
    b       DataAbort
  38:	eafffffe 	b	38 <DataAbort>

0000003c <Reserved>:
Reserved:
    b       Reserved
  3c:	eafffffe 	b	3c <Reserved>

00000040 <Irq>:
Irq:
    b       Irq
  40:	eafffffe 	b	40 <Irq>

00000044 <CallRam>:

.global CallRam
CallRam:
    ldr     r3,     = 0x00200000
  44:	e3a03602 	mov	r3, #2097152	; 0x200000
    bx      r3
  48:	e12fff13 	bx	r3
  4c:	00203ff8 	.word	0x00203ff8

00000050 <ConfigClocks>:
#include <bootrom.h>

extern void CallRam(void);

static void ConfigClocks(void)
{
  50:	b580      	push	{r7, lr}
  52:	b082      	sub	sp, #8
  54:	af00      	add	r7, sp, #0
    volatile int i;

    // we are using a 18.432 MHz crystal as the basis for everything
    PMC_SYS_CLK_ENABLE = PMC_SYS_CLK_PROCESSOR_CLK | PMC_SYS_CLK_UDP_CLK;
  56:	4b19      	ldr	r3, [pc, #100]	; (bc <ConfigClocks+0x6c>)
  58:	2281      	movs	r2, #129	; 0x81
  5a:	601a      	str	r2, [r3, #0]

    PMC_PERIPHERAL_CLK_ENABLE =
  5c:	4b18      	ldr	r3, [pc, #96]	; (c0 <ConfigClocks+0x70>)
  5e:	4a19      	ldr	r2, [pc, #100]	; (c4 <ConfigClocks+0x74>)
  60:	601a      	str	r2, [r3, #0]
        (1<<PERIPH_SPI) |
        (1<<PERIPH_SSC) |
        (1<<PERIPH_PWMC) |
        (1<<PERIPH_UDP);

    PMC_MAIN_OSCILLATOR = PMC_MAIN_OSCILLATOR_ENABLE |
  62:	4b19      	ldr	r3, [pc, #100]	; (c8 <ConfigClocks+0x78>)
  64:	4a19      	ldr	r2, [pc, #100]	; (cc <ConfigClocks+0x7c>)
  66:	601a      	str	r2, [r3, #0]
    // TODO: THIS DEPENDS ON THE CRYSTAL FREQUENCY THAT YOU CHOOSE. Make
    // the ARM run at some reasonable speed, and make the USB peripheral
    // run at exactly 48 MHz.
	
    // minimum PLL clock frequency is 80 MHz in range 00 (96 here so okay)
    PMC_PLL = PMC_PLL_DIVISOR(14) | PMC_PLL_COUNT_BEFORE_LOCK(28) |
  68:	4b19      	ldr	r3, [pc, #100]	; (d0 <ConfigClocks+0x80>)
  6a:	4a1a      	ldr	r2, [pc, #104]	; (d4 <ConfigClocks+0x84>)
  6c:	601a      	str	r2, [r3, #0]
        PMC_PLL_FREQUENCY_RANGE(0) | PMC_PLL_MULTIPLIER(73) |
        PMC_PLL_USB_DIVISOR(1);

    // let the PLL spin up, plenty of time
    for(i = 0; i < 100; i++)
  6e:	2300      	movs	r3, #0
  70:	607b      	str	r3, [r7, #4]
  72:	e002      	b.n	7a <ConfigClocks+0x2a>
  74:	687b      	ldr	r3, [r7, #4]
  76:	3301      	adds	r3, #1
  78:	607b      	str	r3, [r7, #4]
  7a:	687b      	ldr	r3, [r7, #4]
  7c:	2b63      	cmp	r3, #99	; 0x63
  7e:	ddf9      	ble.n	74 <ConfigClocks+0x24>
        ;

    PMC_MASTER_CLK = PMC_CLK_SELECTION_SLOW_CLOCK | PMC_CLK_PRESCALE_DIV_2;
  80:	4b15      	ldr	r3, [pc, #84]	; (d8 <ConfigClocks+0x88>)
  82:	2204      	movs	r2, #4
  84:	601a      	str	r2, [r3, #0]

    for(i = 0; i < 100; i++)
  86:	2300      	movs	r3, #0
  88:	607b      	str	r3, [r7, #4]
  8a:	e002      	b.n	92 <ConfigClocks+0x42>
  8c:	687b      	ldr	r3, [r7, #4]
  8e:	3301      	adds	r3, #1
  90:	607b      	str	r3, [r7, #4]
  92:	687b      	ldr	r3, [r7, #4]
  94:	2b63      	cmp	r3, #99	; 0x63
  96:	ddf9      	ble.n	8c <ConfigClocks+0x3c>
        ;

    PMC_MASTER_CLK = PMC_CLK_SELECTION_PLL_CLOCK | PMC_CLK_PRESCALE_DIV_2;
  98:	4b0f      	ldr	r3, [pc, #60]	; (d8 <ConfigClocks+0x88>)
  9a:	2207      	movs	r2, #7
  9c:	601a      	str	r2, [r3, #0]

    for(i = 0; i < 100; i++)
  9e:	2300      	movs	r3, #0
  a0:	607b      	str	r3, [r7, #4]
  a2:	e002      	b.n	aa <ConfigClocks+0x5a>
  a4:	687b      	ldr	r3, [r7, #4]
  a6:	3301      	adds	r3, #1
  a8:	607b      	str	r3, [r7, #4]
  aa:	687b      	ldr	r3, [r7, #4]
  ac:	2b63      	cmp	r3, #99	; 0x63
  ae:	ddf9      	ble.n	a4 <ConfigClocks+0x54>
        ;
}
  b0:	46bd      	mov	sp, r7
  b2:	b002      	add	sp, #8
  b4:	bc80      	pop	{r7}
  b6:	bc01      	pop	{r0}
  b8:	4700      	bx	r0
  ba:	46c0      	nop			; (mov r8, r8)
  bc:	fffffc00 	.word	0xfffffc00
  c0:	fffffc10 	.word	0xfffffc10
  c4:	00000d34 	.word	0x00000d34
  c8:	fffffc20 	.word	0xfffffc20
  cc:	00004001 	.word	0x00004001
  d0:	fffffc2c 	.word	0xfffffc2c
  d4:	10481c0e 	.word	0x10481c0e
  d8:	fffffc30 	.word	0xfffffc30

000000dc <CMain>:


void CMain(void)
{
  dc:	b580      	push	{r7, lr}
  de:	b084      	sub	sp, #16
  e0:	af00      	add	r7, sp, #0
    int i;

    volatile DWORD *src = (volatile DWORD *)0x200;
  e2:	2380      	movs	r3, #128	; 0x80
  e4:	009b      	lsls	r3, r3, #2
  e6:	60bb      	str	r3, [r7, #8]
    volatile DWORD *dest = (volatile DWORD *)0x00200000;
  e8:	2380      	movs	r3, #128	; 0x80
  ea:	039b      	lsls	r3, r3, #14
  ec:	607b      	str	r3, [r7, #4]

	// Configure the flash that we are running out of (soon).
	MC_FLASH_MODE = MC_FLASH_MODE_FLASH_WAIT_STATES(1) |
  ee:	23a0      	movs	r3, #160	; 0xa0
  f0:	425b      	negs	r3, r3
  f2:	4a11      	ldr	r2, [pc, #68]	; (138 <CMain+0x5c>)
  f4:	601a      	str	r2, [r3, #0]
		MC_FLASH_MODE_MASTER_CLK_IN_MHZ(48);

    ConfigClocks();
  f6:	f7ff ffab 	bl	50 <ConfigClocks>

    for(i = 0; i < 1024; i++) {
  fa:	2300      	movs	r3, #0
  fc:	60fb      	str	r3, [r7, #12]
  fe:	e00f      	b.n	120 <CMain+0x44>
        *dest++ = *src++;
 100:	68bb      	ldr	r3, [r7, #8]
 102:	681a      	ldr	r2, [r3, #0]
 104:	687b      	ldr	r3, [r7, #4]
 106:	601a      	str	r2, [r3, #0]
 108:	687b      	ldr	r3, [r7, #4]
 10a:	3304      	adds	r3, #4
 10c:	607b      	str	r3, [r7, #4]
 10e:	68bb      	ldr	r3, [r7, #8]
 110:	3304      	adds	r3, #4
 112:	60bb      	str	r3, [r7, #8]
        WDT_HIT();
 114:	4b09      	ldr	r3, [pc, #36]	; (13c <CMain+0x60>)
 116:	4a0a      	ldr	r2, [pc, #40]	; (140 <CMain+0x64>)
 118:	601a      	str	r2, [r3, #0]
	MC_FLASH_MODE = MC_FLASH_MODE_FLASH_WAIT_STATES(1) |
		MC_FLASH_MODE_MASTER_CLK_IN_MHZ(48);

    ConfigClocks();

    for(i = 0; i < 1024; i++) {
 11a:	68fb      	ldr	r3, [r7, #12]
 11c:	3301      	adds	r3, #1
 11e:	60fb      	str	r3, [r7, #12]
 120:	68fa      	ldr	r2, [r7, #12]
 122:	4b08      	ldr	r3, [pc, #32]	; (144 <CMain+0x68>)
 124:	429a      	cmp	r2, r3
 126:	ddeb      	ble.n	100 <CMain+0x24>
        *dest++ = *src++;
        WDT_HIT();
    }

    CallRam();
 128:	f000 f814 	bl	154 <__CallRam_from_thumb>
}
 12c:	46bd      	mov	sp, r7
 12e:	b004      	add	sp, #16
 130:	bc80      	pop	{r7}
 132:	bc01      	pop	{r0}
 134:	4700      	bx	r0
 136:	46c0      	nop			; (mov r8, r8)
 138:	00300100 	.word	0x00300100
 13c:	fffffd40 	.word	0xfffffd40
 140:	a5000001 	.word	0xa5000001
 144:	000003ff 	.word	0x000003ff

00000148 <__CMain_from_arm>:
 148:	e59fc000 	ldr	ip, [pc, #0]	; 150 <__CMain_from_arm+0x8>
 14c:	e12fff1c 	bx	ip
 150:	000000dd 	.word	0x000000dd

00000154 <__CallRam_from_thumb>:
 154:	4778      	bx	pc
 156:	46c0      	nop			; (mov r8, r8)
 158:	eaffffb9 	b	44 <CallRam>
 15c:	00000000 	andeq	r0, r0, r0
